


# ðŸ§  Reactâ€™s `useMemo` â€” What, Why, and When to Use It

Reactâ€™s `useMemo` is one of those hooks that seems easy to ignore â€” until you hit performance bottlenecks or expensive recalculations.

Letâ€™s break down what `useMemo` does, its syntax, some real-life use cases, and how I used it in a food ordering modal to validate user selections.

---

## ðŸ” What is `useMemo`?

`useMemo` is a React hook that **memoizes the result of a computation**. This means it **remembers** the result until its dependencies change, so the function inside it doesnâ€™t re-run unnecessarily.

---

## ðŸ§ª Syntax

> ```js
> const memoizedValue = useMemo(() => {
>   // Some expensive calculation
>   return result
> }, [dependencies])
> ```

It will re-run the function **only if one or more dependencies change**.

---

## âœ… Why Use It?

- Avoid unnecessary recalculations  
- Improve performance in frequently re-rendering components  
- Prevent lag when doing expensive operations  

---

## ðŸ’¡ Real Use Cases

### 1. **Filtering a Large Dataset**

> ```js
> const filteredData = useMemo(() => {
>   return data.filter(item => item.isActive)
> }, [data])
> ```

Avoids re-filtering the list unless `data` changes.

---

### 2. **Sorting Expensive Computation**

> ```js
> const sortedList = useMemo(() => {
>   return list.sort((a, b) => a.name.localeCompare(b.name))
> }, [list])
> ```

Helpful when `list` is large and sorting is costly.

---

### 3. **Derived State from Props**

> ```js
> const isEligible = useMemo(() => {
>   return user.age > 18 && user.status === "verified"
> }, [user.age, user.status])
> ```

Clean way to derive boolean flags from complex prop values.

---

## ðŸ• My Real Use Case â€” Deal Validator

I was building a food ordering modal where users could select:
- Pizza sizes  
- Burger flavors inside meal deals  
- Quantity of each item  

The â€œAdd to Cartâ€ button had to stay **disabled** until all selections were valid.

So I memoized the validation logic:

> ```js
> const isAddToCartDisabled = useMemo(() => {
>   if (category === "Pizza") {
>     return pizzaSizes.length !== quantity || pizzaSizes.some((size) => !size)
>   }
> 
>   if (category === "Deals" && dealItems.length > 0) {
>     const nonDefaultItems = dealItems.filter((item) => !item.isDefault)
>     for (let i = 0; i < nonDefaultItems.length; i++) {
>       const item = nonDefaultItems[i]
>       const required = item.quantity * quantity
>       const current = selectedDealData.selectedFlavours[i] || []
>       if (current.length !== required || current.some((s) => !s)) {
>         return true
>       }
>     }
>   }
> 
>   return false
> }, [category, pizzaSizes, quantity, selectedDealData.selectedFlavours, dealItems])
> ```

This saved unnecessary recomputations on every render while keeping validation fast and clean.

---

## ðŸš€ Final Thoughts

Use `useMemo` when:
- Youâ€™re running **expensive logic**
- Your component **re-renders often**
- You want to **optimize derived values**

Donâ€™t overuse it. But when it fits â€” it really shines.

---
